package Distributed;

public class Core {

    // - redis
    // - zookeeper (分布式协调服务)
    // - hadoop hdfs（分布式存储系统）
    // - spark（分布式计算系统）
    // - storm（分布式流式计算系统）
    // - elasticsearch（分布式搜索系统）
    // - kafka（分布式发布订阅消息系统）
    // - Springcloud (分布式完整解决方案)
    // - SpringCloud Hoxton: // https://segmentfault.com/a/1190000004474543
    public static void main(String[] args) {
        // CAP:
        // 一致性(Consistency) : 在分布式系统中的所有数据备份，在同一时刻是否有同样的值
        // 可用性(Availability) : 非故障的节点在合理的时间内返回合理的响应, 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写要求
        // 分区容忍性(Partition Tolerance) : 系统如果不能在一定时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择
        //
        // BASE(AP的一种方式):
        // Basically Available(基本可用): 分布式系统在出现故障时，允许损失部分可用性，即保证核心可用
        // SofState(软状态): 允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是CAP理论中的数据不一致。
        // 最终一致性(Eventual Consistency): 系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。
        // 其解决的问题就是在分布式系统中如何就某个值（决议）达成一致
    }

    public static void handleTCC() {
        // Try-Confirm-Cancel
        // Try: 预留资源
        // Confirm: 确认提交
        // Cancel: 撤回(回滚)
        // EasyTransaction、TccTransaction、Hmily
    }

    public static void handle2PC() {
        // XA协议的实现方式之一: 3PC 两阶段提交
        // 2PC协议也成为2段提交(1prepare阶段,2commit阶段)。
        // prepare: 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。
        // commit; 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)
        //
        // 缺点：
        // 1、同步阻塞: 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
        // 2、单点故障: 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
        // 3、数据不一致: 在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。
        // 4、事物提交性未知: 协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
    }

    public static void handle3PC() {
        // XA协议的实现方式之一: 3PC 三阶段提交
        // 相比2PC新增的逻辑:
        // 1、引入超时机制。同时在协调者和参与者中都引入超时机制。
        // 2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
        // 3PC把2PC的准备阶段再次一分为二，组成完整的三阶段提交拥有: CanCommit、PreCommit、DoCommit三个阶段
        //
        // CanCommit: 协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
        // PreCommit: 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
        // doCommit: 该阶段进行真正的事务提交，也可以分为以下两种情况。

        // 优缺点:
        // 3PC优点：相比2PC
        // 3PC缺点：Precommit阶段后，出现网络分区，无法确定是提交还是回滚，默认提交的话，可能出现数据不一致。
    }


    // Zookeeper的ZAB算法和Raft一致性算法都是基于Paxos的
    public static void handlePaxos() {

        // 前提: Paxos算法的前提假设是不存在拜占庭将军问题，信道是安全的（信道可靠），发出的信号不会被篡改，因为Paxos算法是基于消息传递的。
        // 拜占庭将军问题：是指拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，只能依靠通讯员进行传递命令，但是通讯员中存在叛徒，它们可以篡改消息，叛徒可以欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。
        // 为了避免单点故障，会有一个Acceptor集合，Proposer想Acceptor集合发送提案，Acceptor集合中的每个成员都有可能同意该提案且每个Acceptor只能批准一个提案，只有当一半以上的成员同意了一个提案，就认为该提案被选定了。


        // 阶段一（prepare阶段）:
        //  Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。Pareper（N）
        //  如果一个Acceptor收到一个编号为N的Prepare请求，如果小于它已经响应过的请求，则拒绝，不回应或回复error。若N大于该Acceptor已经响应过的所有Prepare请求的编号（maxN），那么它就会将它已经接受过（已经经过第二阶段accept的提案）的编号最大的提案（如果有的话，如果还没有的accept提案的话返回{pok，null，null}）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。
        // 阶段二 (accept阶段):

        // zookeeper
        // CP系统：强一致性
        // https://my.oschina.net/u/150175/blog/2992187
        // 三个角色：
        //  - Proposer：议案发起者。
        //  - Acceptor：决策者，可以批准议案。
        //
        // 1.0 超过半数的的议案就是最终的选定值，在议案提交后，只需查一下就能确定最终值。
        // P0. 当集群中，超过半数的Acceptor接受了一个议案，那我们就可以说这个议案被选定了（Chosen）。
        //  - 无法100%确定议案超过半数
        //      - 允许一个Acceptor接受多个议案，后接受的议案可以覆盖掉之前接受的议案。
        // (Target0 Target1).一次选举必须选定出有且只有一个议案。
        // P1.一个Acceptor必须接受它收到的第一个议案
        // 对Proposer的每个议案进行编号，并且单调递增
        // P2： 如果一个值为v的议案被选定了，那么被选定的更大编号的议案，它的值必须也是v。
        // P2a：如果一个值为v的议案被选定了，那么Acceptor接受的更大编号的议案，它的值必须也是v。
        // P2b：如果一个值为v的议案被选定了，那么Proposer提出的更大编号的议案，它的值必须也是v。
        // P2c：在所有Acceptor中，任意选取半数以上的Acceptor集合，我们称这个集合为S。Proposal新提出的议案（简称Pnew）必须符合下面两个条件之一：
        //   1）如果S中所有Acceptor都没有接受过议案的话，那么Pnew的编号保证唯一性和递增即可，Pnew的值可以是任意值。
        //   2）如果S中有一个或多个Acceptor曾经接受过议案的话，要先找出其中编号最大的那个议案，假设它的编号为N，值为V。那么Pnew的编号必须大于N，Pnew的值必须等于V。‘
        //  
        // 当一个议案在提出时（即使已经在发送的半路上了），它必须能够知道当前已经提出的议案的最大编号
        // 议案（n，v）在提出前，必须将自己的编号通知给半数以上的Acceptor。收到通知的Acceptor将n跟自己之前收到的通知进行比较，如果n更大，就将n确认为最大编号。当半数以上Acceptor确认n是最大编号时，议案（n，v）才能正式提交。
        // Acceptor收到一个新的编号n，在确认n比自己之前收到的编号大时，必须做出承诺（Promise）：不再接受比n小的议案
        //
        // 如果我们将半数以上的Acceptor对同一个议案（n，v）做出承诺的状态称作是“锁定”状态。那么这个“锁定”状态具有以下性质：
        // 排它性：所有比n小的议案都不允许提交，已经在途的议案，则不允许其形成多数派。
        // 唯一性：任意时刻，全局只有一个议案能获得“锁定”状态。
        // 原子性： 议案n从锁定状态变为非锁定状态的过程是原子的，议案n+1从非锁定状态变更为锁定状态的过程也是原子的。

        // 随着议案的提出，最终的决定是收敛的，才能最终达成唯一解
        //  - Proposer(议案发起者)，发起议案是有条件的
        //      - 任意选取半数以上的Acceptor集合，称为S:
        //          - 议案（n，v）在提出前，必须将自己的编号通知给半数以上的Acceptor
        //              - 收到通知的Acceptor将n跟自己之前收到的通知进行比较，如果n更大，就确认n为最大编号
        //              - 当半数以上Acceptor确认n是最大编号时，议案（n，v）才能正式提出
        //          - 如果S中所有Acceptor都没有接受过议案的话，那么Pnew的编号保证唯一性和递增即可，Pnew的值可以是任意值.
        //          - 如果S中有一个或多个Acceptor曾经接受过议案的话，要先找出其中编号最大的那个议案，假设它的编号为N，值为V。那么Pnew的编号必须大于N，Pnew的值必须等于V。
        //  - Acceptor(议案接受者)，接受议案是有条件的
        //      - 如果一个值为v的议案被选定了，那么Acceptor接受的更大编号的议案，它的值必须也是v。
    }

    public static void handleRaft() {
        // 节点状态:
        //  - Follower
        //  - Candidate
        //  - Leader
        // https://www.cnblogs.com/xybaby/p/10124083.html
    }
}
